# Guntamatic data logging

## Purpose

This repo documents my trials to
* retrieve the status info from a Guntamatic(TM?) Powerchip 50 (TM?) wood chip cauldron 
* store the status in a round robin rrd data base
* provide a web interface to retrieve and browse in the data

Goal is to understand the behaviour of the system over time for optimization and to identify undesired states.

The manufacturerer offers a web (and mobile) client, but I was not satisfied with that
* limited data subset
* only one item plotted per chart, so it's difficult to undestand interrelations 
* long, odd, changing plot interval (e. g. 53 min)
* history is lost after some days and after a restart of the controller

There are different solutions out there, e.g. in the realm of home management frameworks or generic data collectors (cacti beeing the best known one).
May be, they may provide a faster way towards some simple subset of what I have done.
To my impression, at a certain level of customization they provide more obstacles in form of an "obscurity" level.
In the end, any unconstrained turing capable generic programming language inevitably provides more flexibility.

The cauldron controller has a web interface with DHCP configured by default.
There is a MODBUS API as well, but I was perfectly happy with the HTTP API.
My cauldron has Sotware v 32f. It requires a key for API access, which has to be generated by Guntamatic support.
They also may send you a API manual.
It appears to be derived from the serial number, so there is no point in reusing it.
Earlier versions were reported to provice data access witout a special key or with a generic one.

There are five addresses I worked with, belonging to two slightly different API:
`http://w.x.y.z/daqdesc.cgi?key=....` \n separated live data
`http://w.x.y.z/daqdata.cgi?key=....` \n separated mapping
`http://w.x.y.z/ext/daqdesc.cgi?key=....` JSON live data 
`http://w.x.y.z/ext/daqdata.cgi?key=....` JSON mapping
`http://w.x.y.z/par.cgi` static config info

I started with the JSON API, because the format allowed an one-line-`wget` command in `crontab` to collect log files.
It was until I started parsing, rrd logging and pretty printing when I found out that the JSON API was only a subset of the \n API.
While all heater installation parameters are there, essential cauldron and chip feed information is missing.

So I switched to the newline-API halfway during the project.
Files tagged with "plain..." refer to the newline-API. 
I kept the JSON versions for reference. 

Important parts of the code:

`config_plain.pm` is where core information of the protocol is kept.
It keeps structure in sync between rrd, the logger and the renderer.
Configuration at the `edge` of the installation may be keppt in the header area of any of the scripts.

It's derived from the JSON daqdesc, but completed and added up with further processing decisions.
The goal was to change fields, rrds, plotting style etc without fiddling in the hot code.
I think I made that for some 80 % or so. 

The config is included into most other parts.
So make sure it meets PERL syntax on any chages.
I used `parse-confi-plain.pl` to check for syntax errors and to debug available config data structures.
`library.pm`does what it says.

There are some `config-foo-bar.*` perl or shell scripts which setup rrd databases and rendering rrd graph templates.
I used them as a reproducible way for setup and controlled modification.
Once stable, I prefer to remove the `-x` mode flag as a protecion  against accidential deletion of rrd.

The main worker is `log2rrd.pl`.
It polls the cauldron controller once per minute and logs into several rrd databases to be created under `rrd/`
After some trials I ended up with 60 s polling rate and haveing the step, the DS hearbeat and the first RRA consoildation in sync with that.
Log times are rounded to even fractions of minutes.
Half of the variables are boolean states or integer encoded enums. Without proper alignment, I end up with fractional values in the rrd, even if choosing LAST as CF C_onsolidations F_unction.

Web Visualisation is provided by the `guntamatic.pl` script in  `/render`.
It allows moving and zooming through the in time scale.

It must be configured as CGI with perl enabled in the web server. I use `lighttpd`.
Temporary rrd graphs are stored in `/render/tmp`. This must be readable and writable by the web server. Group acces for `www-data` group works fine on my out-of-the-box-debian. Newer versions of charts overwrite older ones. This saves the need of temp cleanup. It is not really thread save, but that does not hurt in a low frequency machine surveillance environment.

The render script works on `rrd-graph` templates, which are basically rrdtool graph commands with some leading lines missing.
The renderer adds rrd filename, start time, end time and a default chart size, as well as some vertical lines as event markers.
The renderer also includes frames with a human readable list of all current state of variables and a subset of event log, matching the time frame displayed in the charts.



Disclaimer:
This all is alpha-state 'works-for-me'-level-stuff.
NEVER USE THIS IN A REAL WORD ENVIRONMENT!
... and if you do anyway, don't sue me.
Expect stuff going wrong.

Don't expect seamless installation out of the box.
Do not even try it without sound knowledge of linux, perl, rrd, shell script and networking.

The Guntamatic-API allows writes to the controller as well.
I did not explicitly try it, but can we sure that this does not happen by accident?
I's an oven, so, in the end, it's supposed to have fire in it. 
And you don't want to have the fire outside, do you?
There is stuff that may break, and moving parts (augers, e.g.!) that may hurt people.
Or at least stop working, destroy warranty claims, and whatever other evil things.



