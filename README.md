# Guntamatic data logging


## Example

![screenshot](/images/my-rrd-log-2021-01-15.png)


## Purpose

This repo documents my endeavour to
* retrieve the status info from a Guntamatic(TM?) Powerchip 50 (TM?) wood chip cauldron 
* store the status in a round robin rrd data base - RTFM: https://oss.oetiker.ch/rrdtool/
* provide a web interface to retrieve and browse the data

Goal is to understand the behaviour of the system over time for optimization and to identify undesired states.

The manufacturerer offers a clude based web service and mobile client.  
I was not satisfied with that, because of  
* limited data subset
* only one item plotted per chart, so it's difficult to undestand interrelations 
* long, odd, changing plot interval (sth. like e. g. 53 min)
* history is lost after some days and after a restart of the controller

However, the manufacturer's tools allow some remote alarm and control of the cauldron, which I do not intend to implement.  
I see no reason why not to use those tools in parallel with my charting framework.  

There are different solutions out there, e.g. in the realm of home management frameworks (FHEM, just to name one) or generic data collectors (cacti beeing the best known one).  
May be, they may provide a faster way towards some simple subset of what I have done.  
To my impression, at a certain level of customization, they provide more obstacles in form of an "obscurity" level.  
In the end, any unconstrained turing capable generic programming language inevitably provides more flexibility.  

## Setup

The cauldron controller has a web interface with DHCP configured by default.
There is a MODBUS API as well, but I was perfectly happy with the HTTP API.  

My cauldron's controller runs Sotware v `32f`.   
It requires a key for API access, which has to be generated by Guntamatic support.  
They also may send you a API manual.  

The key seems to be derived from the serial number, so there is no point in reusing it.  
Earlier versions were reported to provide data access witout a special key or with a generic one, but I was not able to reproduce such instructions.  
  
There are five addresses I worked with, belonging to two slightly different API:  
* `http://w.x.y.z/daqdesc.cgi?key=....` \n separated live data  
* `http://w.x.y.z/daqdata.cgi?key=....` \n separated mapping  
* `http://w.x.y.z/ext/daqdesc.cgi?key=....` JSON live data   
* `http://w.x.y.z/ext/daqdata.cgi?key=....` JSON mapping  
* `http://w.x.y.z/par.cgi` static config info  
  
I started with the JSON API, because the format allowed an one-line-`wget`-command in `crontab` to collect log files.  
It was until I started parsing, rrd logging and pretty printing when I found out that the JSON API was only a subset of the newline API.  
While all parameters that refer to building installation are there, essential internal cauldron and chip feed information is missing.  
  
So I switched to the newline-API halfway during the project.  
Files tagged with `plain...` refer to the newline-API.   
Half baken brethen of those witout the plain-tagging may still be lingering around.
I kept the JSON versions for reference.   

## Key elements of the code:

`config_plain.pm` is where core information of the protocol is kept.  
It keeps structure in sync between rrd, the logger and the renderer.   
Configuration at the 'edge' of the installation, however, may be kept in a decentralize manner in the header area of any of the scripts.

The config is derived from the JSON daqdesc, but completed and added up with further processing decisions.
The goal was to change fields, rrds, plotting style etc without fiddling in the hot code.
I think I made that for some 80 % or so. 

The config is ~~included~~ require'd into most other parts.
So I must be sure it meets PERL syntax on any chages.  
I used `parse-confi-plain.pl` to check for syntax errors and to debug available config data structures.  
  
`library.pm` - well, a library, as it says.  
  
There are some `config-foo-bar.sh|pl` perl or shell scripts which setup rrd databases rendering rrd graph templates and the like.  
I used them as a reproducible way for setup and controlled modification.  
Once stable, I prefer to set them as not executable as a protecion against accidential deletion of rrd.  
  
The main worker is `log2rrd.pl`.  
It polls the cauldron controller once per minute and logs into several rrd databases to be created under `rrd/`.  
After some trials I ended up with 60 s polling rate.  
It proove to be a good idea to have the step, the DS hearbeat and the first RRA consoildation in sync with that.  
Log times are rounded to even fractions of minutes.  

Why? Half of the variables are boolean states or integer encoded enums.  
Without proper alignment, I end up with fractional values in the rrd, even if choosing LAST as CF C_onsolidations F_unction.  
For reasons: RTFM rrd.  

## Web Visualisation 

is provided by the `guntamatic.pl` script in  `/render`.
It allows easy and fast moving and zooming through time scale.

It must be configured as `CGI` with perl enabled in the web server. I use `lighttpd`.  
  
Temporary rrd graphs are stored in `/render/tmp`.  
This must be readable and writable by the web server. Group acces for `www-data` group works fine on my out-of-the-box-debian.  
Newer versions of charts overwrite older ones. This saves the need of temp cleanup.  
It is not really thread save, but that does not hurt in a low frequency machine surveillance environment.  
  
The render script relies on `rrd-graph` templates, which are basically rrdtool graph commands with some leading lines omitted.   
The renderer adds rrd filename, start time, end time and a default chart size, as well as some vertical lines as event markers.  
The `test-...` templates are edited manually, derived from drraw created boiler plates.  

The `gen-...` template are generated by scripts in the main dir. I used this for the somewhat more complicated task to visualize the boolean and the enum fields.  To tune them, I use four screens with vi on the creator, a console to run the creator at every reload cycle, a browswer window to view the rendering and a console to grep error messages out of /var/log/messages in case of `internal server error`. That's where I appreciate my dual screen installation...

The renderer also includes frames with a human readable list of all current state of variables and a subset of event log, matching the time frame displayed in the charts. They are created by silly little log-range.pl and current-state.pl

While I tried to catch worst security holes on the fly, there was no thorough safety planning.  
I hope I can rely on my LAN safety...   



## Disclaimer:

This all is alpha-state 'works-for-me'-level-stuff.  
**NEVER USE THIS IN A REAL WORD ENVIRONMENT!**  
... and if you do anyway, don't sue me.
**Expect stuff going wrong.**  
  
Don't expect seamless installation out of the box.  
Do not even try it without sound knowledge of linux, perl, rrd, shell script, CGI and networking.  
  
The Guntamatic-**API allows writes to the controller** as well.  
I did not explicitly try it, but can we sure that this does not happen by accident?  
I's an **oven**, so, in the end, it's supposed to have **fire in it**.  
And you don't want to have the **fire outside**, do you?  
There is stuff that may break, and **moving parts (augers, e.g.!) that may hurt people**.  
Or at least stop working, destroy warranty claims, and whatever other evil things.



